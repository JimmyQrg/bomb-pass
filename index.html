<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Bomb Pass</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  html,body{
    height:100%;
    margin:0;
    background: #000;
  }
  /* background.png fills whole screen on lowest layer */
  body{
    background-image: url("images/background.png");
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    display:flex;
    align-items:center;
    justify-content:center;
    font-family: 'Press Start 2P', monospace;
  }

  /* Square canvas centered (largest square that fits window) */
  #gameCanvas{
    image-rendering: pixelated;
    background: transparent; /* allow background.png to show through */
    display:block;
  }

  /* UI windows sit on top and are centered; semi-transparent so background is visible */
  .ui {
    position: absolute;
    top:50%;
    left:50%;
    transform: translate(-50%,-50%);
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:4px; /* buttons closer */
    padding:14px;
    border:3px solid #333;
    background: rgba(0,0,0,0.22);
  }

  .button-img {
    transform: scale(0.5); /* buttons 2× smaller */
    image-rendering: pixelated;
    display:block;
    cursor:pointer;
  }

  .ui input[type="number"]{
    font-family:'Press Start 2P';
    width:80px;
    text-align:center;
    font-size:13px;
    margin-left:8px;
  }

  #gameover { display:none; }
</style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <!-- Menu -->
  <div id="menu" class="ui">
    <img id="btn2" class="button-img" src="images/buttons/start-menu/button-2-players.png" alt="2 players">
    <img id="btn3" class="button-img" src="images/buttons/start-menu/button-3-players.png" alt="3 players">
    <img id="btn4" class="button-img" src="images/buttons/start-menu/button-4-players.png" alt="4 players">
  </div>

  <!-- Settings -->
  <div id="settings" class="ui" style="display:none;">
    <div style="color:white">TIME (5–60s):
      <input id="timeInput" type="number" min="5" max="60" value="20">
    </div>
    <img id="startBtn" class="button-img" src="images/buttons/start-gray.png" alt="Start">
  </div>

  <!-- Game over -->
  <div id="gameover" class="ui">
    <div id="winnerText" style="color:white; text-align:center;"></div>
    <img id="restartBtn" class="button-img" src="images/buttons/restart.png" alt="Restart">
  </div>

<script>
/* -------------- CONFIG -------------- */
const MAP_TILES = 40;               // 40x40 map
const BASE_TILE_PX = 48;            // world tile pixel size reference
const PLAYER_W = Math.floor(BASE_TILE_PX * 0.9);
const PLAYER_H = Math.floor(BASE_TILE_PX * 0.9);
let PLAYER_SPEED_PX = 5.0;          // faster player speed (pixels/frame)
let BOMB_SPEED_PX = 20.0;           // bomb speed (pixels/frame) — increased
const CAMERA_SMOOTH = 0.10;
const PARTICLE_COUNT = 18;

/* -------------- DOM -------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const menu = document.getElementById('menu');
const settings = document.getElementById('settings');
const gameover = document.getElementById('gameover');
const btn2 = document.getElementById('btn2');
const btn3 = document.getElementById('btn3');
const btn4 = document.getElementById('btn4');
const startBtn = document.getElementById('startBtn');
const timeInput = document.getElementById('timeInput');
const restartBtn = document.getElementById('restartBtn');
const winnerText = document.getElementById('winnerText');

/* -------------- IMAGES -------------- */
const imgWall = new Image(); imgWall.src = 'images/blocks/wall.png';
const imgGround = new Image(); imgGround.src = 'images/blocks/ground-slab.png';
const imgBomb = new Image(); imgBomb.src = 'images/bomb.png';
const playerImgs = {};
for(let i=1;i<=4;i++){
  playerImgs['p'+i]  = new Image(); playerImgs['p'+i].src = `images/players/player-${i}.png`;
  playerImgs['pb'+i] = new Image(); playerImgs['pb'+i].src = `images/players/player-${i}-bomb.png`;
}

/* -------------- INPUT -------------- */
let keys = {};         // current frame
let prevKeys = {};     // previous frame for rising-edge detection
window.addEventListener('keydown', e => { keys[e.code] = true; });
window.addEventListener('keyup', e => { keys[e.code] = false; });

/* -------------- STATE -------------- */
let grid = [];              // map tiles
let players = [];           // player objects
let bomb = null;            // bomb object (pixel coords)
let particles = [];         // explosion particles
let trails = [];            // per-player trail arrays
let numPlayers = 2;
let startTime = 20;
let timeLeft = 0;
let timerHandle = null;
let running = false;

/* Camera (tile units) */
let camX = 0, camY = 0;
let camTileSize = canvas.width / MAP_TILES; // pixels per tile used in rendering

/* -------------- Controls mapping -------------- */
/* Throw keys: Q(1) -> KeyQ, /(2) -> Slash, U(3) -> KeyU, R(4) -> KeyR */
const controls = [
  { up:'KeyW',   down:'KeyS', left:'KeyA',   right:'KeyD',   throw:'KeyQ'  },
  { up:'ArrowUp',down:'ArrowDown',left:'ArrowLeft',right:'ArrowRight',throw:'Slash' },
  { up:'KeyI',   down:'KeyK', left:'KeyJ',   right:'KeyL',   throw:'KeyU'  },
  { up:'KeyT',   down:'KeyG', left:'KeyF',   right:'KeyH',   throw:'KeyR'  }
];

const playerColors = [
  'rgba(255,120,120,',
  'rgba(120,255,140,',
  'rgba(120,160,255,',
  'rgba(255,255,120,'
];

/* -------------- UTIL -------------- */
function lerp(a,b,t){ return a + (b-a)*t; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rand(min,max){ return Math.random()*(max-min)+min; }

/* -------------- Resize canvas -------------- */
function resizeCanvas(){
  const size = Math.min(window.innerWidth, window.innerHeight);
  canvas.width = canvas.height = size;
  // update camTileSize fallback
  camTileSize = canvas.width / MAP_TILES;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* -------------- Map generation -------------- */
function generateMap(){
  grid = [];
  for(let y=0;y<MAP_TILES;y++){
    const row = [];
    for(let x=0;x<MAP_TILES;x++){
      if(x===0 || y===0 || x===MAP_TILES-1 || y===MAP_TILES-1 || Math.random() < 0.15) row.push(1);
      else row.push(0);
    }
    grid.push(row);
  }
}

/* -------------- Spawn players (pixel coords centered in tile) -------------- */
function spawnPlayers(){
  players = [];
  trails = [];
  for(let i=0;i<numPlayers;i++){
    let tx, ty;
    do {
      tx = Math.floor(Math.random() * MAP_TILES);
      ty = Math.floor(Math.random() * MAP_TILES);
    } while(grid[ty][tx] === 1 || players.some(p => p.tileX === tx && p.tileY === ty));
    const px = tx * BASE_TILE_PX + (BASE_TILE_PX - PLAYER_W) / 2;
    const py = ty * BASE_TILE_PX + (BASE_TILE_PX - PLAYER_H) / 2;
    players.push({
      id: i+1,
      x: px,
      y: py,
      tileX: tx,
      tileY: ty,
      alive: true,
      hasBomb: false,
      lastDirX: 1,
      lastDirY: 0
    });
    trails.push([]); // trail entries for this player
  }
}

/* -------------- Give bomb to random alive player -------------- */
function giveBomb(){
  const alive = players.filter(p => p.alive);
  if(alive.length === 0){ bomb = null; return; }
  const pick = alive[Math.floor(Math.random()*alive.length)];
  pick.hasBomb = true;
  bomb = {
    x: pick.x + PLAYER_W/2 - (BASE_TILE_PX * 0.6)/2,
    y: pick.y + PLAYER_H/2 - (BASE_TILE_PX * 0.6)/2,
    vx: 0, vy: 0,
    isFlying: false,
    holderIndex: players.indexOf(pick),
    fromIndex: null
  };
}

/* -------------- Collision helpers -------------- */
function rectHitsWall(px, py, w, h){
  const left = Math.floor(px / BASE_TILE_PX);
  const right = Math.floor((px + w - 1) / BASE_TILE_PX);
  const top = Math.floor(py / BASE_TILE_PX);
  const bottom = Math.floor((py + h - 1) / BASE_TILE_PX);
  for(let ty=top; ty<=bottom; ty++){
    if(ty < 0 || ty >= MAP_TILES) return true;
    for(let tx=left; tx<=right; tx++){
      if(tx < 0 || tx >= MAP_TILES) return true;
      if(grid[ty][tx] === 1) return true;
    }
  }
  return false;
}

function rectHitsPlayer(px, py, w, h, excludeIndex=-1){
  for(let i=0;i<players.length;i++){
    if(i === excludeIndex) continue;
    const p = players[i];
    if(!p.alive) continue;
    if(px < p.x + PLAYER_W && px + w > p.x && py < p.y + PLAYER_H && py + h > p.y){
      return i;
    }
  }
  return -1;
}

/* -------------- Particles (explosion) -------------- */
function spawnExplosionAtCenter(px, py){
  // px,py are top-left of tile-like center or pixel center — we spawn particles around center
  const cx = px;
  const cy = py;
  for(let i=0;i<PARTICLE_COUNT;i++){
    const angle = Math.random()*Math.PI*2;
    const speed = rand(1.8, 5.8);
    particles.push({
      x: cx + rand(-8,8),
      y: cy + rand(-8,8),
      vx: Math.cos(angle)*speed,
      vy: Math.sin(angle)*speed - rand(0,1.2),
      life: Math.floor(rand(20,36)),
      age: 0,
      color: `rgba(255,${Math.floor(rand(120,240))},0,`
    });
  }
}

/* Explosion that affects players (px,py are pixel coordinates center-ish) */
function explodeAt(px, py){
  spawnExplosionAtCenter(px, py);
  // kill any players within ~0.9 tile radius
  const radius = BASE_TILE_PX * 0.9;
  players.forEach(p => {
    if(!p.alive) return;
    const cx = p.x + PLAYER_W/2;
    const cy = p.y + PLAYER_H/2;
    const d = Math.hypot(cx - px, cy - py);
    if(d < radius){
      p.alive = false;
      p.hasBomb = false;
    }
  });
}

/* -------------- Timer behavior -------------- */
let tickTimer = null;
function startRoundTimer(){
  if(tickTimer) clearInterval(tickTimer);
  tickTimer = setInterval(()=>{
    timeLeft = Math.max(0, timeLeft - 1);
    if(timeLeft <= 0){
      // explosion due to timer
      if(bomb){
        if(bomb.holderIndex !== null && bomb.holderIndex !== undefined){
          const holder = players[bomb.holderIndex];
          if(holder && holder.alive){
            explodeAt(holder.x + PLAYER_W/2, holder.y + PLAYER_H/2);
            holder.alive = false;
          }
        } else {
          // bomb flying or resting in world
          explodeAt(bomb.x + (BASE_TILE_PX*0.6)/2, bomb.y + (BASE_TILE_PX*0.6)/2);
        }
        bomb = null;
      }
      // check alive players
      const alive = players.filter(p => p.alive);
      if(alive.length <= 1){
        // game over
        running = false;
        clearInterval(tickTimer);
        gameover.style.display = 'flex';
        winnerText.textContent = alive.length === 1 ? `Player ${alive[0].id} Wins!` : 'No one wins';
      } else {
        // new round
        timeLeft = startTime;
        giveBomb();
      }
    }
  }, 1000);
}
function stopRoundTimer(){ if(tickTimer){ clearInterval(tickTimer); tickTimer = null; } }

/* -------------- Rising-edge detection -------------- */
function isNewPress(code){
  return !!keys[code] && !prevKeys[code];
}

/* -------------- Update loop -------------- */
function update(){
  if(!running) return;

  // --- player trails: push current pos (every frame) and cap length ---
  for(let i=0;i<players.length;i++){
    const p = players[i];
    // store center pos for trail
    if(p.alive){
      trails[i].unshift({ x: p.x + PLAYER_W/2, y: p.y + PLAYER_H/2, age: 0 });
      if(trails[i].length > 14) trails[i].pop();
    } else {
      trails[i] = [];
    }
  }

  // --- Movement (pixel-based) ---
  for(let i=0;i<players.length;i++){
    const p = players[i];
    if(!p.alive) continue;
    const ctrl = controls[i];
    let dx = 0, dy = 0;
    if(keys[ctrl.up]) dy -= PLAYER_SPEED_PX;
    if(keys[ctrl.down]) dy += PLAYER_SPEED_PX;
    if(keys[ctrl.left]) dx -= PLAYER_SPEED_PX;
    if(keys[ctrl.right]) dx += PLAYER_SPEED_PX;

    // normalize diagonal speed
    if(dx !== 0 && dy !== 0){
      const m = Math.hypot(dx,dy);
      dx = dx / m * PLAYER_SPEED_PX;
      dy = dy / m * PLAYER_SPEED_PX;
    }

    // update last direction (for throw direction)
    if(Math.abs(dx) > 0.001 || Math.abs(dy) > 0.001){
      const mag = Math.hypot(dx,dy) || 1;
      p.lastDirX = dx / mag;
      p.lastDirY = dy / mag;
    }

    // attempt X move
    if(dx !== 0){
      const nx = p.x + dx;
      if(!rectHitsWall(nx, p.y, PLAYER_W, PLAYER_H) && rectHitsPlayer(nx, p.y, PLAYER_W, PLAYER_H, i) === -1){
        p.x = nx;
      }
    }
    if(dy !== 0){
      const ny = p.y + dy;
      if(!rectHitsWall(p.x, ny, PLAYER_W, PLAYER_H) && rectHitsPlayer(p.x, ny, PLAYER_W, PLAYER_H, i) === -1){
        p.y = ny;
      }
    }

    // keep tile coords updated
    p.tileX = Math.floor((p.x + PLAYER_W/2) / BASE_TILE_PX);
    p.tileY = Math.floor((p.y + PLAYER_H/2) / BASE_TILE_PX);

    // if player holds bomb, update bomb position to follow smoothly
    if(bomb && bomb.holderIndex === i){
      bomb.x = p.x + PLAYER_W/2 - (BASE_TILE_PX*0.6)/2;
      bomb.y = p.y + PLAYER_H/2 - (BASE_TILE_PX*0.6)/2;
    }
  }

  // --- Throw logic (rising-edge) ---
  for(let i=0;i<players.length;i++){
    const p = players[i];
    if(!p.alive) continue;
    const ctrl = controls[i];
    if(p.hasBomb && isNewPress(ctrl.throw)){
      // use lastDir; fallback to right
      let dirX = p.lastDirX || 1;
      let dirY = p.lastDirY || 0;
      const mag = Math.hypot(dirX, dirY) || 1;
      dirX /= mag; dirY /= mag;
      bomb = {
        x: p.x + PLAYER_W/2 - (BASE_TILE_PX*0.6)/2,
        y: p.y + PLAYER_H/2 - (BASE_TILE_PX*0.6)/2,
        vx: dirX * BOMB_SPEED_PX,
        vy: dirY * BOMB_SPEED_PX,
        isFlying: true,
        holderIndex: null,
        fromIndex: i
      };
      p.hasBomb = false;
    }
  }

  // --- Bomb flight ---
  if(bomb && bomb.isFlying){
    bomb.x += bomb.vx;
    bomb.y += bomb.vy;

    // center tile for bomb
    const bx = bomb.x + (BASE_TILE_PX*0.6)/2;
    const by = bomb.y + (BASE_TILE_PX*0.6)/2;
    const tx = Math.floor(bx / BASE_TILE_PX);
    const ty = Math.floor(by / BASE_TILE_PX);

    // check wall collision
    if(tx < 0 || ty < 0 || tx >= MAP_TILES || ty >= MAP_TILES || grid[ty][tx] === 1){
      // return to thrower if alive
      const from = (bomb.fromIndex !== undefined && bomb.fromIndex !== null) ? players[bomb.fromIndex] : null;
      if(from && from.alive){
        from.hasBomb = true;
        bomb = {
          x: from.x + PLAYER_W/2 - (BASE_TILE_PX*0.6)/2,
          y: from.y + PLAYER_H/2 - (BASE_TILE_PX*0.6)/2,
          vx:0, vy:0, isFlying:false, holderIndex: players.indexOf(from), fromIndex: null
        };
      } else {
        // stop bomb where it hit
        bomb.isFlying = false;
        bomb.vx = bomb.vy = 0;
      }
    } else {
      // check collision with players
      for(let i=0;i<players.length;i++){
        const p = players[i];
        if(!p.alive) continue;
        if(bomb.x < p.x + PLAYER_W && bomb.x + (BASE_TILE_PX*0.6) > p.x &&
           bomb.y < p.y + PLAYER_H && bomb.y + (BASE_TILE_PX*0.6) > p.y){
          // hit -> attach to player
          p.hasBomb = true;
          bomb = {
            x: p.x + PLAYER_W/2 - (BASE_TILE_PX*0.6)/2,
            y: p.y + PLAYER_H/2 - (BASE_TILE_PX*0.6)/2,
            vx:0, vy:0, isFlying:false, holderIndex:i, fromIndex:null
          };
          break;
        }
      }
    }
  }

  // --- Particles update ---
  for(let i=particles.length-1;i>=0;i--){
    const sp = particles[i];
    sp.age++;
    sp.x += sp.vx;
    sp.y += sp.vy;
    sp.vy += 0.06; // subtle gravity
    if(sp.age >= sp.life) particles.splice(i,1);
  }

  // --- Camera fit to all alive players ---
  const alivePlayers = players.filter(p => p.alive);
  if(alivePlayers.length > 0){
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    alivePlayers.forEach(p=>{
      const leftTile = (p.x) / BASE_TILE_PX;
      const rightTile = (p.x + PLAYER_W) / BASE_TILE_PX;
      const topTile = (p.y) / BASE_TILE_PX;
      const bottomTile = (p.y + PLAYER_H) / BASE_TILE_PX;
      minX = Math.min(minX, leftTile);
      maxX = Math.max(maxX, rightTile);
      minY = Math.min(minY, topTile);
      maxY = Math.max(maxY, bottomTile);
    });

    const PAD = 1.2; // tiles padding
    const boxWidthTiles = (maxX - minX) + PAD;
    const boxHeightTiles = (maxY - minY) + PAD;

    const baseTilePixel = canvas.width / MAP_TILES; // max zoom-in
    let targetTilePixel = Math.min(canvas.width / boxWidthTiles, canvas.height / boxHeightTiles);
    if(targetTilePixel > baseTilePixel) targetTilePixel = baseTilePixel;

    const centerTileX = (minX + maxX) / 2;
    const centerTileY = (minY + maxY) / 2;

    camTileSize = lerp(camTileSize, targetTilePixel, CAMERA_SMOOTH);
    const targetCamX = centerTileX - (canvas.width / (2 * camTileSize));
    const targetCamY = centerTileY - (canvas.height / (2 * camTileSize));
    camX = lerp(camX, targetCamX, CAMERA_SMOOTH);
    camY = lerp(camY, targetCamY, CAMERA_SMOOTH);
  }

  // --- DRAW ---
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // tiles
  for(let ty=0; ty<MAP_TILES; ty++){
    for(let tx=0; tx<MAP_TILES; tx++){
      const sx = (tx - camX) * camTileSize;
      const sy = (ty - camY) * camTileSize;
      if(sx + camTileSize < 0 || sy + camTileSize < 0 || sx > canvas.width || sy > canvas.height) continue;
      const img = (grid[ty][tx] === 1) ? imgWall : imgGround;
      ctx.drawImage(img, sx, sy, camTileSize, camTileSize);
    }
  }

  // draw trails (pixel glowing outline) — older entries first so they fade outward
  for(let i=0;i<players.length;i++){
    const tr = trails[i];
    if(!tr || tr.length===0) continue;
    const baseColor = playerColors[(i % playerColors.length)];
    for(let t = tr.length -1; t >= 0; t--){
      const ent = tr[t];
      ent.age += 1;
      const life = tr.length; // treat length as life scale
      const intensity = ( (life - t) / life ); // 0..1 older -> smaller intensity
      const alpha = 0.18 * intensity;
      // draw a pixel outline (multiple small rects around center)
      const dx = (ent.x / BASE_TILE_PX - camX) * camTileSize;
      const dy = (ent.y / BASE_TILE_PX - camY) * camTileSize;
      const s = Math.max(2, camTileSize * 0.18 * intensity);
      ctx.fillStyle = baseColor + alpha + ')';
      // offsets (pixel-style outline)
      const offs = [ [0,0],[-0.04,0],[0.04,0],[0,-0.04],[0,0.04],[-0.08,0],[0.08,0],[0,-0.08],[0,0.08] ];
      offs.forEach(o=>{
        ctx.fillRect(dx + o[0]*camTileSize - s/2, dy + o[1]*camTileSize - s/2, s, s);
      });
    }
  }

  // draw players (on top)
  for(let i=0;i<players.length;i++){
    const p = players[i];
    if(!p.alive) continue;
    const sx = (p.x / BASE_TILE_PX - camX) * camTileSize;
    const sy = (p.y / BASE_TILE_PX - camY) * camTileSize;
    const drawW = (PLAYER_W / BASE_TILE_PX) * camTileSize;
    const drawH = (PLAYER_H / BASE_TILE_PX) * camTileSize;
    const img = p.hasBomb ? playerImgs['pb'+p.id] : playerImgs['p'+p.id];
    ctx.drawImage(img, sx, sy, drawW, drawH);
  }

  // draw bomb (if flying or lying on map)
  if(bomb){
    if(!bomb.isFlying && bomb.holderIndex !== null && bomb.holderIndex !== undefined){
      // drawn as part of player's bomb sprite — skip here
    } else {
      const bx = (bomb.x / BASE_TILE_PX - camX) * camTileSize;
      const by = (bomb.y / BASE_TILE_PX - camY) * camTileSize;
      const bw = ( (BASE_TILE_PX*0.6) / BASE_TILE_PX) * camTileSize;
      const bh = bw;
      ctx.drawImage(imgBomb, bx, by, bw, bh);
    }
  }

  // particles
  particles.forEach(sp=>{
    const sx = (sp.x / BASE_TILE_PX - camX) * camTileSize;
    const sy = (sp.y / BASE_TILE_PX - camY) * camTileSize;
    const size = Math.max(1, camTileSize * 0.05);
    const alpha = 1 - (sp.age / sp.life);
    ctx.fillStyle = sp.color + alpha + ')';
    ctx.fillRect(sx, sy, size, size);
  });

  // timer top-left
  ctx.fillStyle = 'white';
  ctx.font = `${Math.max(12, canvas.width/30)}px 'Press Start 2P'`;
  ctx.textBaseline = 'top';
  ctx.fillText(String(Math.ceil(timeLeft)), 8, 8);

  // copy current keys->prevKeys for rising-edge detection
  for(const k in keys) prevKeys[k] = keys[k];

  requestAnimationFrame(update);
}

/* -------------- Start / UI wiring -------------- */
btn2.addEventListener('click', ()=>{ numPlayers = 2; menu.style.display='none'; settings.style.display='flex'; validateStartButton(); });
btn3.addEventListener('click', ()=>{ numPlayers = 3; menu.style.display='none'; settings.style.display='flex'; validateStartButton(); });
btn4.addEventListener('click', ()=>{ numPlayers = 4; menu.style.display='none'; settings.style.display='flex'; validateStartButton(); });

function validateStartButton(){
  const v = parseInt(timeInput.value);
  if(!isNaN(v) && v >= 5 && v <= 60) startBtn.src = 'images/buttons/start.png';
  else startBtn.src = 'images/buttons/start-gray.png';
}
timeInput.addEventListener('input', validateStartButton);

startBtn.addEventListener('click', ()=>{
  const v = parseInt(timeInput.value);
  if(isNaN(v) || v < 5 || v > 60) return;
  startTime = v; timeLeft = startTime;
  generateMap();
  spawnPlayers();
  giveBomb();
  particles = [];
  // reset trails
  trails = players.map(()=>[]);
  running = true;
  camTileSize = canvas.width / MAP_TILES;
  camX = camY = 0;
  // start timer
  stopRoundTimer();
  startRoundTimer();
  // UI hide
  menu.style.display = 'none';
  settings.style.display = 'none';
  gameover.style.display = 'none';
  // clear prevKeys
  prevKeys = {};
  requestAnimationFrame(update);
});

restartBtn.addEventListener('click', ()=> location.reload() );

/* initial UI */
menu.style.display = 'flex';
settings.style.display = 'none';
gameover.style.display = 'none';
validateStartButton();

/* expose debug values (optional) */
window._dbg = { players, bomb, particles, grid };

/* ensure pixel rendering */
ctx.imageSmoothingEnabled = false;
</script>
</body>
</html>
