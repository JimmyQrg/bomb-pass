<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bomb Pass</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #000;
    font-family: 'Press Start 2P', cursive;
  }

  canvas {
    display: block;
    margin: 0 auto;
    image-rendering: pixelated;
  }

  #background {
    position: fixed;
    width: 100%;
    height: 100%;
    background: url("images/background.png") no-repeat center center;
    background-size: cover;
    z-index: 0;
  }

  .menu, .settings {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    z-index: 2;
  }

  h1 {
    color: #fff;
    font-size: 18px;
    margin-bottom: 40px;
    text-shadow: 2px 2px #000;
  }

  .menu button, .settings button {
    display: block;
    margin: 10px auto;
    border: none;
    background: none;
    cursor: pointer;
    transition: transform 0.1s;
  }

  .menu button img, .settings button img {
    width: 180px;
  }

  .menu button:hover img {
    filter: brightness(1.2);
  }

  .menu button:active img {
    transform: scale(0.95);
  }

  .settings input {
    display: block;
    margin: 20px auto;
    padding: 8px;
    text-align: center;
    width: 120px;
    font-size: 12px;
    border: 2px solid #fff;
    background: #222;
    color: #fff;
  }

  #error {
    color: red;
    font-size: 10px;
    display: none;
  }

  #gameCanvas {
    display: none;
  }
</style>
</head>

<body>
  <div id="background"></div>

  <div id="menu" class="menu">
    <h1>BOMB PASS</h1>
    <button id="btn2"><img src="images/buttons/start-menu/button-2-players.png"></button>
    <button id="btn3"><img src="images/buttons/start-menu/button-3-players.png"></button>
    <button id="btn4"><img src="images/buttons/start-menu/button-4-players.png"></button>
  </div>

  <div id="settings" class="settings" style="display:none;">
    <h1>SET GAME TIME</h1>
    <input id="timeInput" type="number" placeholder="5â€“60 sec" min="5" max="60">
    <p id="error">Please enter a value between 5 and 60</p>
    <button id="startBtn">
      <img id="startImg" src="images/buttons/start-gray.png">
    </button>
  </div>

  <canvas id="gameCanvas" width="1280" height="720"></canvas>

<script>
  const menu = document.getElementById("menu");
  const settings = document.getElementById("settings");
  const startBtn = document.getElementById("startBtn");
  const startImg = document.getElementById("startImg");
  const timeInput = document.getElementById("timeInput");
  const error = document.getElementById("error");
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  let playerCount = 2;
  let timeLimit = 0;

  // Handle player select buttons
  document.getElementById("btn2").onclick = () => selectPlayers(2);
  document.getElementById("btn3").onclick = () => selectPlayers(3);
  document.getElementById("btn4").onclick = () => selectPlayers(4);

  function selectPlayers(count) {
    playerCount = count;
    menu.style.display = "none";
    settings.style.display = "block";
  }

  // Validate time input
  timeInput.addEventListener("input", () => {
    const val = parseInt(timeInput.value);
    if (val >= 5 && val <= 60) {
      startImg.src = "images/buttons/start.png";
      startBtn.disabled = false;
      error.style.display = "none";
    } else {
      startImg.src = "images/buttons/start-gray.png";
      startBtn.disabled = true;
      error.style.display = "block";
    }
  });

  // Handle start
  startBtn.onclick = () => {
    if (startBtn.disabled) return;
    timeLimit = parseInt(timeInput.value);
    settings.style.display = "none";
    document.getElementById("background").style.display = "none";
    canvas.style.display = "block";
    startGame();
  };

  // Placeholder for next part
  function startGame() {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#fff";
    ctx.fillText("Game starting...", canvas.width/2 - 100, canvas.height/2);
  }
<script>
let game = null;

function startGame() {
  const TILE_SIZE = 32;
  const MAP_W = 80, MAP_H = 80;
  const players = [];
  const walls = [];
  const ground = [];
  const keys = {};
  const bombImg = new Image();
  bombImg.src = "images/bomb.png";

  // Load player sprites
  const playerImgs = [];
  for (let i = 1; i <= 4; i++) {
    const normal = new Image();
    normal.src = `images/players/player-${i}.png`;
    const bomb = new Image();
    bomb.src = `images/players/player-${i}-bomb.png`;
    playerImgs.push({ normal, bomb });
  }

  const wallImg = new Image();
  wallImg.src = "images/blocks/wall.png";
  const groundImg = new Image();
  groundImg.src = "images/blocks/ground-slab.png";

  // Key bindings
  const controls = [
    { up:'w', down:'s', left:'a', right:'d', throw:'q' },
    { up:'ArrowUp', down:'ArrowDown', left:'ArrowLeft', right:'ArrowRight', throw:'/' },
    { up:'i', down:'k', left:'j', right:'l', throw:'y' },
    { up:'t', down:'g', left:'f', right:'h', throw:'r' }
  ];

  // Build organic maze
  const map = Array(MAP_H).fill().map(()=>Array(MAP_W).fill(0));
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      map[y][x]=0;
    }
  }

  // generate rectangular wall clusters
  const clusters = 40;
  for(let c=0;c<clusters;c++){
    const w = 3+Math.floor(Math.random()*8);
    const h = 3+Math.floor(Math.random()*8);
    const sx = Math.floor(Math.random()*(MAP_W-w-1));
    const sy = Math.floor(Math.random()*(MAP_H-h-1));
    for(let y=sy;y<sy+h;y++){
      for(let x=sx;x<sx+w;x++){
        if(x>=0&&y>=0&&x<MAP_W&&y<MAP_H){
          map[y][x]=1;
        }
      }
    }
  }

  // carve roads 3 blocks wide
  for(let y=3;y<MAP_H;y+=6){
    for(let x=0;x<MAP_W;x++){
      for(let dy=-1;dy<=1;dy++){
        if(map[y+dy]) map[y+dy][x]=0;
      }
    }
  }
  for(let x=3;x<MAP_W;x+=6){
    for(let y=0;y<MAP_H;y++){
      for(let dx=-1;dx<=1;dx++){
        if(map[y] && map[y][x+dx]!==undefined) map[y][x+dx]=0;
      }
    }
  }

  // Build wall/ground objects
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      const img = map[y][x]===1?wallImg:groundImg;
      (map[y][x]===1?walls:ground).push({x,y,img});
    }
  }

  // spawn players
  const spawnPositions = [
    {x:2,y:2},{x:MAP_W-3,y:2},{x:2,y:MAP_H-3},{x:MAP_W-3,y:MAP_H-3}
  ];
  for(let i=0;i<playerCount;i++){
    let {x,y}=spawnPositions[i];
    // teleport out of wall if needed
    while(map[y][x]===1){
      x=Math.floor(Math.random()*MAP_W);
      y=Math.floor(Math.random()*MAP_H);
    }
    players.push({
      id:i,
      x:x*TILE_SIZE,
      y:y*TILE_SIZE,
      w:TILE_SIZE,
      h:TILE_SIZE,
      speed:2,
      hasBomb:false,
      alive:true
    });
  }

  // assign bomb to random player
  let bomb = {
    x:players[0].x, y:players[0].y, size:20,
    vx:0, vy:0, owner:0, flying:false, timer:timeLimit
  };
  players[bomb.owner].hasBomb=true;

  // camera
  let cam = {x:0,y:0,zoom:1};

  // input
  window.onkeydown=e=>keys[e.key]=true;
  window.onkeyup=e=>keys[e.key]=false;

  // main loop
  const FPS=60;
  let elapsed=0;
  const tick=1000/FPS;
  const startTime=Date.now();

  function update(){
    const now=Date.now();
    elapsed=(now-startTime)/1000;
    if(elapsed>bomb.timer){
      // explode
      players[bomb.owner].alive=false;
      endGame();
      return;
    }

    // player movement
    for(let i=0;i<playerCount;i++){
      const p=players[i];
      if(!p.alive) continue;
      const c=controls[i];
      let vx=0,vy=0;
      if(keys[c.up])vy=-1;
      if(keys[c.down])vy=1;
      if(keys[c.left])vx=-1;
      if(keys[c.right])vx=1;
      const spd=p.hasBomb?3:2;
      const nx=p.x+vx*spd;
      const ny=p.y+vy*spd;

      // collision with walls
      if(!isCollide(nx, p.y, p))p.x=nx;
      if(!isCollide(p.x, ny, p))p.y=ny;

      // throw
      if(keys[c.throw] && p.hasBomb && !bomb.flying){
        const dir={x:vx,y:vy};
        if(dir.x!==0||dir.y!==0){
          bomb.flying=true;
          bomb.vx=dir.x*6;
          bomb.vy=dir.y*6;
          p.hasBomb=false;
        }
      }
    }

    // bomb flight
    if(bomb.flying){
      bomb.x+=bomb.vx;
      bomb.y+=bomb.vy;
      // hit wall?
      const tx=Math.floor(bomb.x/TILE_SIZE);
      const ty=Math.floor(bomb.y/TILE_SIZE);
      if(map[ty] && map[ty][tx]===1){
        // return to owner
        bomb.flying=false;
        bomb.vx=bomb.vy=0;
        players[bomb.owner].hasBomb=true;
      }
      // hit player
      for(const p of players){
        if(p.alive && !p.hasBomb && Math.abs(p.x-bomb.x)<20 && Math.abs(p.y-bomb.y)<20){
          bomb.flying=false;
          bomb.vx=bomb.vy=0;
          bomb.owner=p.id;
          p.hasBomb=true;
        }
      }
    } else {
      bomb.x=players[bomb.owner].x;
      bomb.y=players[bomb.owner].y;
    }

    // camera follow all
    updateCamera();

    draw();
    requestAnimationFrame(update);
  }

  function updateCamera(){
    // center around players
    const xs=players.filter(p=>p.alive).map(p=>p.x);
    const ys=players.filter(p=>p.alive).map(p=>p.y);
    const minx=Math.min(...xs),maxx=Math.max(...xs);
    const miny=Math.min(...ys),maxy=Math.max(...ys);
    const cx=(minx+maxx)/2;
    const cy=(miny+maxy)/2;
    const dx=maxx-minx, dy=maxy-miny;
    const dist=Math.max(dx,dy);
    cam.zoom=Math.max(0.8,Math.min(1.6,400/(dist+200)));
    cam.x=cx - canvas.width/(2*cam.zoom);
    cam.y=cy - canvas.height/(2*cam.zoom);
    // lock inside map
    cam.x=Math.max(0,Math.min(cam.x,MAP_W*TILE_SIZE-canvas.width/cam.zoom));
    cam.y=Math.max(0,Math.min(cam.y,MAP_H*TILE_SIZE-canvas.height/cam.zoom));
  }

  function isCollide(nx,ny,p){
    const gx=Math.floor(nx/TILE_SIZE);
    const gy=Math.floor(ny/TILE_SIZE);
    for(let dy=0;dy<1;dy++){
      for(let dx=0;dx<1;dx++){
        if(map[gy+dy] && map[gy+dy][gx+dx]===1) return true;
      }
    }
    return false;
  }

  function draw(){
    ctx.save();
    ctx.setTransform(cam.zoom,0,0,cam.zoom,-cam.x*cam.zoom,-cam.y*cam.zoom);
    ctx.clearRect(0,0,canvas.width/cam.zoom,canvas.height/cam.zoom);
    for(const g of ground){ctx.drawImage(g.img,g.x*TILE_SIZE,g.y*TILE_SIZE,TILE_SIZE,TILE_SIZE);}
    for(const w of walls){ctx.drawImage(w.img,w.x*TILE_SIZE,w.y*TILE_SIZE,TILE_SIZE,TILE_SIZE);}
    for(const p of players){
      if(!p.alive) continue;
      const img=p.hasBomb?playerImgs[p.id].bomb:playerImgs[p.id].normal;
      ctx.drawImage(img,p.x,p.y,p.w,p.h);
    }
    ctx.drawImage(bombImg,bomb.x,bomb.y,bomb.size,bomb.size);
    ctx.restore();

    // draw timer
    ctx.fillStyle="white";
    ctx.font="12px 'Press Start 2P'";
    ctx.fillText("TIME: "+Math.max(0,(bomb.timer-elapsed)).toFixed(1),20,20);
  }

  function endGame(){
    ctx.fillStyle="red";
    ctx.font="20px 'Press Start 2P'";
    ctx.fillText("BOOM!",canvas.width/2-60,canvas.height/2);
  }

  update();
}

</script>
</body>
</html>
