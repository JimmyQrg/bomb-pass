<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Bomb Pass</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  html,body{
    height:100%;
    margin:0;
  }
  /* background.png fills whole screen on lowest layer */
  body{
    background-image: url("images/background.png");
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    display:flex;
    align-items:center;
    justify-content:center;
    font-family: 'Press Start 2P', monospace;
    -webkit-font-smoothing: none;
    -moz-osx-font-smoothing: grayscale;
  }

  /* Square canvas centered (largest square that fits window) */
  #gameCanvas{
    image-rendering: pixelated;
    background: #000; /* black borders visible around canvas */
    display:block;
    box-shadow: 0 0 0 6px rgba(0,0,0,0.6);
  }

  /* UI windows sit on top and are centered */
  .ui {
    position: absolute;
    top:50%;
    left:50%;
    transform: translate(-50%,-50%);
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:6px; /* buttons closer */
    padding:18px;
    border:4px solid #444;
    background: rgba(0,0,0,0.25); /* semi see-through so background.png is visible */
  }

  .ui img.button-img {
    transform: scale(0.5); /* buttons 2× smaller */
    image-rendering: pixelated;
    display:block;
  }

  .ui input[type="number"]{
    font-family:'Press Start 2P';
    width:80px;
    text-align:center;
    font-size:13px;
    margin-left:8px;
  }

  #gameover { display:none; }
</style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <!-- Menu -->
  <div id="menu" class="ui">
    <img id="btn2" class="button-img" src="images/buttons/start-menu/button-2-players.png" alt="2 players">
    <img id="btn3" class="button-img" src="images/buttons/start-menu/button-3-players.png" alt="3 players">
    <img id="btn4" class="button-img" src="images/buttons/start-menu/button-4-players.png" alt="4 players">
  </div>

  <!-- Settings -->
  <div id="settings" class="ui" style="display:none;">
    <div style="color:white">TIME (5–60s):
      <input id="timeInput" type="number" min="5" max="60" value="20">
    </div>
    <img id="startBtn" class="button-img" src="images/buttons/start-gray.png" alt="Start">
  </div>

  <!-- Game over -->
  <div id="gameover" class="ui">
    <div id="winnerText" style="color:white; text-align:center;"></div>
    <img id="restartBtn" class="button-img" src="images/buttons/restart.png" alt="Restart">
  </div>

<script>
/* ---------- Config ---------- */
const MAP_TILES = 40;               // 40x40 map
const BASE_TILE_PX = 48;            // world tile pixel size (world coordinates use px; each tile = 48px)
const PLAYER_DRAW_TILE_RATIO = 1.0; // draw players at 1 tile size by default (scaled by camera)
const PLAYER_W = BASE_TILE_PX * 0.9; // player bounding-box (px)
const PLAYER_H = BASE_TILE_PX * 0.9;
const BOMB_SIZE_PX = BASE_TILE_PX * 0.6;
const PLAYER_SPEED_PX = 3.5;        // pixels per frame (you asked faster)
const BOMB_SPEED_PX = 9;            // pixels per frame for thrown bomb
const CAMERA_SMOOTH = 0.10;         // lerp factor for camera movement & zoom
const PARTICLE_COUNT = 16;

/* ---------- DOM ---------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const menu = document.getElementById('menu');
const settings = document.getElementById('settings');
const gameover = document.getElementById('gameover');
const btn2 = document.getElementById('btn2');
const btn3 = document.getElementById('btn3');
const btn4 = document.getElementById('btn4');
const startBtn = document.getElementById('startBtn');
const startImg = document.getElementById('startBtn');
const timeInput = document.getElementById('timeInput');
const restartBtn = document.getElementById('restartBtn');
const winnerText = document.getElementById('winnerText');

/* ---------- Images ---------- */
const imgWall = new Image(); imgWall.src = 'images/blocks/wall.png';
const imgGround = new Image(); imgGround.src = 'images/blocks/ground-slab.png';
const imgBomb = new Image(); imgBomb.src = 'images/bomb.png';
const playerImgs = {};
for(let i=1;i<=4;i++){
  playerImgs['p'+i] = new Image(); playerImgs['p'+i].src = `images/players/player-${i}.png`;
  playerImgs['pb'+i] = new Image(); playerImgs['pb'+i].src = `images/players/player-${i}-bomb.png`;
}

/* ---------- Input ---------- */
let keys = {};        // current
let prevKeys = {};    // previous frame (for rising-edge detection)
window.addEventListener('keydown', e => { keys[e.code] = true; });
window.addEventListener('keyup', e => { keys[e.code] = false; });

/* ---------- Game state ---------- */
let grid = []; // 2D tile array: 0 ground, 1 wall
let players = []; // array of player objects {id,x,y,alive,hasBomb,lastDirX,lastDirY}
let bomb = null;  // {x,y,vx,vy,isFlying,holderIndex,fromIndex}
let particles = []; // explosion particles
let numPlayers = 2;
let startTime = 20;   // seconds for round (updated by settings)
let timeLeft = 0;     // seconds left in the round
let timerInterval = null;
let running = false;

/* ---------- Camera (in tile units) ---------- */
let camX = 0; // top-left tile coordinate
let camY = 0;
let camTileSize = 0; // pixels per tile used for rendering (changes with zoom)

/* ---------- Controls mapping (codes) ---------- */
/* Throw keys: Q(1) -> KeyQ, /(2) -> Slash, U(3) -> KeyU, R(4) -> KeyR */
const controls = [
  { up:'KeyW', down:'KeyS', left:'KeyA', right:'KeyD', throw:'KeyQ' },
  { up:'ArrowUp', down:'ArrowDown', left:'ArrowLeft', right:'ArrowRight', throw:'Slash' },
  { up:'KeyI', down:'KeyK', left:'KeyJ', right:'KeyL', throw:'KeyU' },
  { up:'KeyT', down:'KeyG', left:'KeyF', right:'KeyH', throw:'KeyR' }
];

/* ---------- Utilities ---------- */
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function lerp(a,b,t){ return a + (b-a) * t; }
function rand(min,max){ return Math.random()*(max-min)+min; }

/* ---------- Resize canvas (largest square inside window) ---------- */
function resizeCanvas(){
  const size = Math.min(window.innerWidth, window.innerHeight);
  canvas.width = canvas.height = size;
  // Recompute cam base tile later in render step
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* ---------- Map generation ---------- */
function generateMap(){
  grid = [];
  for(let y=0;y<MAP_TILES;y++){
    const row = [];
    for(let x=0;x<MAP_TILES;x++){
      if(x===0 || y===0 || x===MAP_TILES-1 || y===MAP_TILES-1 || Math.random() < 0.15) row.push(1);
      else row.push(0);
    }
    grid.push(row);
  }
}

/* ---------- Spawn players (pixel positions centered in tile) ---------- */
function spawnPlayers(){
  players = [];
  for(let i=0;i<numPlayers;i++){
    let tx, ty;
    do{
      tx = Math.floor(Math.random()*MAP_TILES);
      ty = Math.floor(Math.random()*MAP_TILES);
    } while(grid[ty][tx] === 1 || players.some(p => p.tileX === tx && p.tileY === ty));
    // pixel coordinates: top-left of centered sprite inside tile
    const px = tx * BASE_TILE_PX + (BASE_TILE_PX - PLAYER_W) / 2;
    const py = ty * BASE_TILE_PX + (BASE_TILE_PX - PLAYER_H) / 2;
    players.push({
      id: i+1,
      x: px,
      y: py,
      alive: true,
      hasBomb: false,
      lastDirX: 1, // default facing right
      lastDirY: 0,
      tileX: tx,
      tileY: ty
    });
  }
}

/* ---------- Give bomb to random alive player ---------- */
function giveBomb(){
  const alive = players.filter(p => p.alive);
  if(alive.length === 0) { bomb = null; return; }
  const pick = alive[Math.floor(Math.random()*alive.length)];
  pick.hasBomb = true;
  bomb = {
    x: pick.x + PLAYER_W/2 - BOMB_SIZE_PX/2,
    y: pick.y + PLAYER_H/2 - BOMB_SIZE_PX/2,
    vx: 0, vy: 0,
    isFlying: false,
    holderIndex: players.indexOf(pick),
    fromIndex: null
  };
}

/* ---------- Utility: check wall collision of a rect (px coords) ---------- */
function rectHitsWall(px, py, w, h){
  // compute covered tile range
  const left = Math.floor(px / BASE_TILE_PX);
  const right = Math.floor((px + w - 1) / BASE_TILE_PX);
  const top = Math.floor(py / BASE_TILE_PX);
  const bottom = Math.floor((py + h - 1) / BASE_TILE_PX);
  for(let ty = top; ty <= bottom; ty++){
    if(ty < 0 || ty >= MAP_TILES) return true;
    for(let tx = left; tx <= right; tx++){
      if(tx < 0 || tx >= MAP_TILES) return true;
      if(grid[ty][tx] === 1) return true;
    }
  }
  return false;
}

/* ---------- Utility: players collision (rect overlap) ---------- */
function rectHitsPlayer(px, py, w, h, excludeIndex = -1){
  for(let i=0;i<players.length;i++){
    if(i === excludeIndex) continue;
    const p = players[i];
    if(!p.alive) continue;
    const px2 = p.x, py2 = p.y, w2 = PLAYER_W, h2 = PLAYER_H;
    if(px < px2 + w2 && px + w > px2 && py < py2 + h2 && py + h > py2){
      return i;
    }
  }
  return -1;
}

/* ---------- Explosion particles ---------- */
function spawnExplosion(px, py){
  for(let i=0;i<PARTICLE_COUNT;i++){
    const angle = Math.random()*Math.PI*2;
    const speed = rand(1.5, 4.5);
    particles.push({
      x: px,
      y: py,
      vx: Math.cos(angle)*speed,
      vy: Math.sin(angle)*speed - rand(0,1.5),
      life: rand(18,38),
      age: 0,
      color: `rgba(255,${Math.floor(rand(120,200))},0,1)`
    });
  }
}

/* ---------- Handle explosion at tile (center) ---------- */
function explodeAt(x, y){
  // x,y in pixels (top-left). spawn particles at center.
  const cx = x + PLAYER_W/2;
  const cy = y + PLAYER_H/2;
  spawnExplosion(cx, cy);

  // kill any players whose bounding boxes intersect the explosion tile
  players.forEach(p => {
    if(!p.alive) return;
    // simple distance check to center -> kill if within 0.9 * tile
    const pxCenter = p.x + PLAYER_W/2;
    const pyCenter = p.y + PLAYER_H/2;
    const dx = pxCenter - cx;
    const dy = pyCenter - cy;
    const dist = Math.hypot(dx, dy);
    if(dist < BASE_TILE_PX * 0.9){
      p.alive = false;
      p.hasBomb = false;
    }
  });
}

/* ---------- Timer control ---------- */
let timerTickHandle = null;
function startRoundTimer(){
  if(timerTickHandle) clearInterval(timerTickHandle);
  timerTickHandle = setInterval(() => {
    timeLeft = Math.max(0, timeLeft - 1);
    if(timeLeft <= 0){
      // trigger explosion now
      handleRoundEndByTimer();
    }
  }, 1000);
}
function stopRoundTimer(){
  if(timerTickHandle){ clearInterval(timerTickHandle); timerTickHandle = null; }
}

/* ---------- When time runs out for a round ---------- */
function handleRoundEndByTimer(){
  stopRoundTimer();
  // if bomb held, explode at holder; if flying explode at bomb pos
  if(bomb){
    if(bomb.holderIndex !== null && bomb.holderIndex !== undefined){
      const holder = players[bomb.holderIndex];
      if(holder && holder.alive){
        explodeAt(holder.x, holder.y);
        holder.alive = false;
      }
    } else {
      // bomb position explosion
      explodeAt(bomb.x, bomb.y);
    }
    bomb = null;
  }

  // remove dead players and decide next round or end
  const alive = players.filter(p => p.alive);
  if(alive.length <= 1){
    // end game
    running = false;
    stopRoundTimer();
    gameover.style.display = 'flex';
    winnerText.textContent = alive.length === 1 ? `Player ${alive[0].id} Wins!` : 'No one wins';
  } else {
    // restart round: reset timer and give a bomb
    timeLeft = startTime;
    giveBomb();
    startRoundTimer();
  }
}

/* ---------- Throw detection helper (rising-edge) ---------- */
function isNewPress(code){
  return !!keys[code] && !prevKeys[code];
}

/* ---------- Main update loop ---------- */
function update(){
  if(!running) return;

  // --- Movement (pixel-based) ---
  for(let i=0;i<players.length;i++){
    const p = players[i];
    if(!p.alive) continue;
    let dx = 0, dy = 0;
    const ctrl = controls[i];
    if(keys[ctrl.up]) dy -= PLAYER_SPEED_PX;
    if(keys[ctrl.down]) dy += PLAYER_SPEED_PX;
    if(keys[ctrl.left]) dx -= PLAYER_SPEED_PX;
    if(keys[ctrl.right]) dx += PLAYER_SPEED_PX;

    // Update lastDir for throwing intent if movement input present
    if(dx !== 0 || dy !== 0){
      const mag = Math.hypot(dx,dy) || 1;
      p.lastDirX = dx/mag;
      p.lastDirY = dy/mag;
    }

    // Try move X
    if(dx !== 0){
      const newX = p.x + dx;
      if(!rectHitsWall(newX, p.y, PLAYER_W, PLAYER_H) && rectHitsPlayer(newX, p.y, PLAYER_W, PLAYER_H, i) === -1){
        p.x = newX;
      }
    }
    // Try move Y
    if(dy !== 0){
      const newY = p.y + dy;
      if(!rectHitsWall(p.x, newY, PLAYER_W, PLAYER_H) && rectHitsPlayer(p.x, newY, PLAYER_W, PLAYER_H, i) === -1){
        p.y = newY;
      }
    }

    // keep tile indices (for spawn logic etc.)
    p.tileX = Math.floor((p.x + PLAYER_W/2) / BASE_TILE_PX);
    p.tileY = Math.floor((p.y + PLAYER_H/2) / BASE_TILE_PX);
  }

  // --- Throw logic (rising edge only) ---
  for(let i=0;i<players.length;i++){
    const p = players[i];
    if(!p.alive) continue;
    const ctrl = controls[i];
    if(p.hasBomb && isNewPress(ctrl.throw)){
      // Use player's lastDir (pixel vector). If zero, default to right.
      let dirX = p.lastDirX || 1;
      let dirY = p.lastDirY || 0;
      // normalize
      const mag = Math.hypot(dirX, dirY) || 1;
      dirX /= mag;
      dirY /= mag;
      // start bomb flying from center of player
      bomb = {
        x: p.x + PLAYER_W/2 - BOMB_SIZE_PX/2,
        y: p.y + PLAYER_H/2 - BOMB_SIZE_PX/2,
        vx: dirX * BOMB_SPEED_PX,
        vy: dirY * BOMB_SPEED_PX,
        isFlying: true,
        holderIndex: null,
        fromIndex: i
      };
      p.hasBomb = false;
    }
  }

  // --- Bomb flight (pixel-based) ---
  if(bomb && bomb.isFlying){
    bomb.x += bomb.vx;
    bomb.y += bomb.vy;

    // collision with walls (tile check)
    const tx = Math.floor((bomb.x + BOMB_SIZE_PX/2) / BASE_TILE_PX);
    const ty = Math.floor((bomb.y + BOMB_SIZE_PX/2) / BASE_TILE_PX);
    if(tx < 0 || ty < 0 || tx >= MAP_TILES || ty >= MAP_TILES || grid[ty][tx] === 1){
      // return to thrower
      const from = (bomb.fromIndex !== undefined && bomb.fromIndex !== null) ? players[bomb.fromIndex] : null;
      if(from && from.alive){
        from.hasBomb = true;
        bomb = {
          x: from.x + PLAYER_W/2 - BOMB_SIZE_PX/2,
          y: from.y + PLAYER_H/2 - BOMB_SIZE_PX/2,
          vx: 0, vy: 0, isFlying: false, holderIndex: players.indexOf(from), fromIndex: null
        };
      } else {
        // no thrower alive, simply stop the bomb where it hit
        bomb.isFlying = false;
        bomb.vx = bomb.vy = 0;
        bomb.holderIndex = null;
      }
    } else {
      // collision with players (simple bounding-box hit)
      for(let i=0;i<players.length;i++){
        const p = players[i];
        if(!p.alive) continue;
        const px = p.x, py = p.y;
        if(bomb.x < px + PLAYER_W && bomb.x + BOMB_SIZE_PX > px &&
           bomb.y < py + PLAYER_H && bomb.y + BOMB_SIZE_PX > py){
          // hit player -> that player gets bomb
          p.hasBomb = true;
          bomb = {
            x: p.x + PLAYER_W/2 - BOMB_SIZE_PX/2,
            y: p.y + PLAYER_H/2 - BOMB_SIZE_PX/2,
            vx:0,vy:0,isFlying:false,holderIndex:i,fromIndex:null
          };
          break;
        }
      }
    }
  }

  // --- Round timer and explosion handled by timer tick (see startRoundTimer) ---

  // --- Update particles ---
  for(let i = particles.length-1; i>=0; i--){
    const sp = particles[i];
    sp.age++;
    sp.x += sp.vx;
    sp.y += sp.vy;
    sp.vy += 0.12; // gravity for particles
    if(sp.age > sp.life) particles.splice(i,1);
  }

  // --- Camera: compute target that fits all alive players (in tile units) ---
  const alivePlayers = players.filter(p => p.alive);
  if(alivePlayers.length > 0){
    let minTx = Infinity, maxTx = -Infinity, minTy = Infinity, maxTy = -Infinity;
    alivePlayers.forEach(p=>{
      const leftTile = (p.x) / BASE_TILE_PX;
      const rightTile = (p.x + PLAYER_W) / BASE_TILE_PX;
      const topTile = (p.y) / BASE_TILE_PX;
      const bottomTile = (p.y + PLAYER_H) / BASE_TILE_PX;
      minTx = Math.min(minTx, leftTile);
      maxTx = Math.max(maxTx, rightTile);
      minTy = Math.min(minTy, topTile);
      maxTy = Math.max(maxTy, bottomTile);
    });
    // padding in tiles
    const PAD = 1.2;
    const boxWidthTiles = (maxTx - minTx) + PAD;
    const boxHeightTiles = (maxTy - minTy) + PAD;

    const baseTile = canvas.width / MAP_TILES; // max zoom-in (pixels per tile)
    let targetTileSize = Math.min(canvas.width / boxWidthTiles, canvas.height / boxHeightTiles);
    if(targetTileSize > baseTile) targetTileSize = baseTile;

    // center in tile units
    const centerTileX = (minTx + maxTx) / 2;
    const centerTileY = (minTy + maxTy) / 2;

    // smooth lerp camera
    camTileSize = lerp(camTileSize || baseTile, targetTileSize, CAMERA_SMOOTH);
    const targetCamX = centerTileX - (canvas.width / (2*camTileSize));
    const targetCamY = centerTileY - (canvas.height / (2*camTileSize));
    camX = lerp(camX, targetCamX, CAMERA_SMOOTH);
    camY = lerp(camY, targetCamY, CAMERA_SMOOTH);
  }

  // --- Draw world using camTileSize (pixels per tile) ---
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Tiles
  for(let ty=0; ty<MAP_TILES; ty++){
    for(let tx=0; tx<MAP_TILES; tx++){
      const sx = (tx - camX) * camTileSize;
      const sy = (ty - camY) * camTileSize;
      // skip tiles outside screen
      if(sx + camTileSize < 0 || sy + camTileSize < 0 || sx > canvas.width || sy > canvas.height) continue;
      const img = (grid[ty][tx] === 1) ? imgWall : imgGround;
      ctx.drawImage(img, sx, sy, camTileSize, camTileSize);
    }
  }

  // Players
  players.forEach(p=>{
    if(!p.alive) return;
    const sx = ((p.x)/BASE_TILE_PX - camX) * camTileSize;
    const sy = ((p.y)/BASE_TILE_PX - camY) * camTileSize;
    const drawW = (PLAYER_W / BASE_TILE_PX) * camTileSize;
    const drawH = (PLAYER_H / BASE_TILE_PX) * camTileSize;
    const img = p.hasBomb ? playerImgs['pb'+p.id] : playerImgs['p'+p.id];
    ctx.drawImage(img, sx, sy, drawW, drawH);
  });

  // Bomb if flying or held by none
  if(bomb && !bomb.isFlying && bomb.holderIndex != null){
    // bomb on holder (we draw as part of player's sprite; so skip)
  } else if(bomb){
    const sx = ((bomb.x)/BASE_TILE_PX - camX) * camTileSize;
    const sy = ((bomb.y)/BASE_TILE_PX - camY) * camTileSize;
    const drawW = (BOMB_SIZE_PX / BASE_TILE_PX) * camTileSize;
    const drawH = (BOMB_SIZE_PX / BASE_TILE_PX) * camTileSize;
    ctx.drawImage(imgBomb, sx, sy, drawW, drawH);
  }

  // Particles
  particles.forEach(p=>{
    const sx = (p.x / BASE_TILE_PX - camX) * camTileSize;
    const sy = (p.y / BASE_TILE_PX - camY) * camTileSize;
    const alpha = 1 - (p.age / p.life);
    ctx.fillStyle = p.color.replace(/,1\)$/, ',' + alpha + ')');
    const size = Math.max(1, (camTileSize * 0.06));
    ctx.fillRect(sx, sy, size, size);
  });

  // Timer top-left inside canvas (safe margin)
  ctx.fillStyle = "white";
  ctx.font = `${Math.max(12, canvas.width/30)}px 'Press Start 2P'`;
  ctx.textBaseline = 'top';
  ctx.fillText(String(Math.ceil(timeLeft)), 8, 8);

  // update prevKeys (rising-edge detection)
  for(let k in keys) prevKeys[k] = keys[k];

  requestAnimationFrame(update);
}

/* ---------- Start game ---------- */
function startGame(){
  // read and validate time input
  const val = parseInt(timeInput.value);
  if(isNaN(val) || val < 5 || val > 60) return;
  startTime = val;
  timeLeft = startTime;

  // reset
  generateMap();
  spawnPlayers();
  giveBomb();
  particles = [];
  running = true;
  camX = 0; camY = 0; camTileSize = canvas.width / MAP_TILES;

  // start round timer
  stopRoundTimer();
  startRoundTimer();

  // UI hide
  settings.style.display = 'none';
  menu.style.display = 'none';
  gameover.style.display = 'none';

  // clear prevKeys
  prevKeys = {};
  // begin update loop
  requestAnimationFrame(update);
}

/* ---------- Deal with timer-based explosion if needed (already used by timer) ---------- */
/* handleRoundEndByTimer defined above */

/* ---------- Button wiring ---------- */
btn2.addEventListener('click', ()=>{ numPlayers = 2; menu.style.display='none'; settings.style.display='flex'; startImg.src = 'images/buttons/start-gray.png'; startBtn.src='images/buttons/start-gray.png'; });
btn3.addEventListener('click', ()=>{ numPlayers = 3; menu.style.display='none'; settings.style.display='flex'; startImg.src = 'images/buttons/start-gray.png'; startBtn.src='images/buttons/start-gray.png'; });
btn4.addEventListener('click', ()=>{ numPlayers = 4; menu.style.display='none'; settings.style.display='flex'; startImg.src = 'images/buttons/start-gray.png'; startBtn.src='images/buttons/start-gray.png'; });

// Start button visual control
function validateStartButton(){
  const v = parseInt(timeInput.value);
  if(!isNaN(v) && v >=5 && v <= 60){
    startBtn.src = 'images/buttons/start.png';
  } else {
    startBtn.src = 'images/buttons/start-gray.png';
  }
}
timeInput.addEventListener('input', validateStartButton);
startBtn.addEventListener('click', startGame);

// Restart
restartBtn.addEventListener('click', ()=> location.reload());

/* ---------- initial UI state ---------- */
menu.style.display = 'flex';
settings.style.display = 'none';
gameover.style.display = 'none';
validateStartButton();

/* ---------- expose some helpers for debug in console (optional) ---------- */
window._gp = ()=>({players, bomb, grid, particles});
</script>
</body>
</html>
